import os
import base64
import re

def is_base64(encoded_string):
    """
    Check if a string is valid base64 encoded.
    
    Args:
        encoded_string: The string to check
        
    Returns:
        bool: True if the string is valid base64, False otherwise
    """
    try:
        # Add padding if needed (base64 strings must be multiples of 4)
        missing_padding = len(encoded_string) % 4
        if missing_padding:
            encoded_string += '=' * (4 - missing_padding)
        
        # Try to decode and re-encode to verify it's valid base64
        decoded = base64.b64decode(encoded_string, validate=False)
        re_encoded = base64.b64encode(decoded).decode().rstrip('=')
        return re_encoded == encoded_string.rstrip('=')
    except Exception:
        return False

def decode_base64(encoded_string):
    """
    Decode a base64 string with proper padding.
    
    Args:
        encoded_string: The base64 string to decode
        
    Returns:
        str: The decoded string
    """
    # Add padding if needed
    if len(encoded_string) % 4:
        encoded_string += '=' * (4 - len(encoded_string) % 4)
    return base64.b64decode(encoded_string).decode(errors='ignore')

def find_secret_base64(file_path):
    """
    Search a file for double-encoded base64 strings containing secrets.
    
    Args:
        file_path: Path to the file to scan
        
    Returns:
        list: List of tuples containing (original, decoded_secret)
    """
    secret_matches = []
    
    with open(file_path, 'r', errors='ignore') as file:
        for line in file:
            # Find potential base64 strings (20+ characters of base64 alphabet)
            potential_base64 = re.findall(r'[A-Za-z0-9+/=]{20,}', line)
            
            for encoded in potential_base64:
                if is_base64(encoded):
                    # First decode
                    intermediate = decode_base64(encoded)
                    
                    # Check if first decode is also base64
                    if is_base64(intermediate):
                        # Second decode to get the secret
                        decoded_secret = decode_base64(intermediate)
                        
                        # Check if it contains a secret
                        if '"isSecret":true' in decoded_secret:
                            secret_matches.append((encoded, decoded_secret))
    
    return secret_matches

def scan_for_secrets(directory):
    """
    Recursively scan a directory for files containing secret base64 strings.
    
    Args:
        directory: Directory path to scan
        
    Returns:
        dict: Dictionary mapping file paths to their secret matches
    """
    results = {}
    
    for root, _, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            matches = find_secret_base64(file_path)
            
            if matches:
                results[file_path] = matches
    
    return results

def print_results(results):
    """
    Print the results in a readable format.
    
    Args:
        results: Dictionary of results from scan_for_secrets
    """
    if not results:
        print("No secret base64 strings found.")
        return
    
    print("\nFound secret base64 strings in the following files:")
    print("-" * 50)
    
    for file_path, matches in results.items():
        print(f"\nFile: {file_path}")
        print("-" * 30)
        
        for i, (encoded, decoded_secret) in enumerate(matches, 1):
            print(f"\nMatch #{i}:")
            print(f"Original: {encoded}")
            print(f"Decoded Secret: {decoded_secret}")

def main():
    """
    Main function to run the secret scanner.
    
    """
    print("tj-actions CVE-2025-30066 Scanner")
    print("Scan Workflow logs to detect comrpomised secrets")
    print("=" * 20)
    
    directory = input("\nEnter workflow logs directory to scan: ").strip()
    
    if not os.path.exists(directory):
        print(f"Error: Directory '{directory}' does not exist.")
        return
    
    print("\nScanning...")
    results = scan_for_secrets(directory)
    print_results(results)

if __name__ == "__main__":
    main()
